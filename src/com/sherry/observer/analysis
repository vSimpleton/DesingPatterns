Head First定义观察者模式：
观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会受到通知并自动更新。

遵循的OO原则：
封装变化
多用组合，少用继承
针对接口编程，不针对实现编程
为交互对象之间的松耦合设计而努力

以上的代码都是自己实现的Observable，若用Java API内置的Observable，则违反了我们的OO设计原则：针对接口编程，而非针对实现编程。
因为java.util.Observable是一个类而不是一个接口。

观察者模式的效果有以下的优点：
（1）观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。
被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口，观察者模式可以让主题对象和观察者对象之间松耦合。
（2）观察者模式支持广播通讯。被观察者会向所有的登记过的观察者发出通知。
（3）观察者模式满足“开-闭原则”。主题接口仅仅依赖于观察者接口，这样，就可以让创建具体主题的类也仅仅是依赖于观察者接口，因此，如果增加新的实现观察者接口的类，
不必修改创建具体主题的类的代码。同样，创建具体观察者的类仅仅依赖于主题接口，如果增加新的实现主题接口的类，也不必修改创建具体观察者类的代码。

观察者模式有下面的缺点：
（1）如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
（2）如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。
（3）如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。
（4）虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。

观察者模式的应用场景：
1、 对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。
2、 对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。

可能会造成的问题：
当被观察者发生动作了，观察者要做出回应，如果观察者比较多，而且处理时间比较长，就使用异步，异步处理就要考虑线程安全和队列的问题。
